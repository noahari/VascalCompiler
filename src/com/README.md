#Vascal Compiler

##Version 0.25: Parser Implemented with Lexer fixes

To run this file:

- Pull the files from github maintaining the directory structure

- cd into src/com and javac *.java

- cd back out to src and run com.Parser

- The output corresponds to the test file located in src/com/LanguageResources/ultcorrected.txt

*Note: Due to path differences, if it is preferable to run in intellij as opposed to the
command line, the correct file paths are noted below comments containing the searchable phrase "" \*INTELLIJ\* "*

*In order to run in intellij, comment out the line above that demarcation, and de-comment the line
below that demarcation in Parser.java, RHSTable.java, and ParseTable.java. Then simply execute the
main method in Parser.java*

###Changelog:

####Version 0.2.5
>Implemented Parser in an abstracted, generalized method that can read an input Grammar
and Parse Table, and use it to properly parse an input file. Since it reads these from a file,
the Parser can simply be directed to read files that construct a different language and then 
serve as a working parser for that language.

>Error handling that tracks down the line of the error and reports what kind of error,
 i.e Unexpected SEMICOLON following <identifier-list> at line 36. Gives line of error,
 as well as read Token that caused the error and the top of the parse stack at the moment
 of error.


>Lexer bug fixes: 
* >Caught edge case where some real constant tokens where the character
after that token would be consumed and ignored. 
* >Fixed overly static Lexer, and used dynamic
references to fix a Parsing bug where progressive lexing produced error in the Unary vs Addop
distinction.

####Version 0.1
>Implemented Lexer with handling for Keywords, Identifiers, Numbers, and Symbols.

>Checks for valid characters; 
 valid construction of comments, constants, and identifiers; 
 ensures whitespace surrounding identifiers;
 checks if constant or identifier exceeds max allowed length; 
 and throws custom errors if any of these conditions are not met
 
 >Properly handles '..' and scientific notation edge cases, as well as malformed constants
 where each are interrupted with an unexpected character (e.g. 5. , 5.3e. , 5.3ea, 5.a)
 
 >Currently, this is too static. I ran out of time to rework this but I am aware and
 this will be improved upon in subsequent versions.
 
 
 ##History
 
 ###Version 0.1: Lexer Implemented
 
 To run this file: 
 
 -Place all .java files and txt test files into a directory called "com"
 
 - Compile it
 
 - Move the working directory to the directory above the com directory
  
 - Ensure test files are in the same directory as the compiled classes 
  
 - Run Lexer.class with an argument giving it the name of the test file WITH file extension.
 
 -For example use command line argument: "java com.Lexer lextexttest.txt"
 
 
 The currently coded test file is a test file generated by a tool made by Jacob Schwartz. I included a handwritten testfile if it is not
 acceptable to use a randomly generated test file if that test file was generated by a tool I
 did not create.
 
 Here are the two arguments for the test files:
 
 ./lextexttest.txt

 
 ##Acknowledgements
 Parker: Thanks for being a very helpful coach during your hours 
 
 Jacob Schwartz: Thanks for generating a testfile 
 that is more expansive than one I could write by hand.